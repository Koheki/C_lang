
## 2章：プログラムの書き方

### 関数の書き方
```
型名 関数名(引数){

    処理

    return 0;
    }
```

## 3章：画面への表示

### 疑似命令の取り込み
疑似命令
- プログラムコードでない命令
- 機械語に翻訳されず、その前段階で処理される
- main関数よりも上に書く必要がある
- 関数の外側に書ける

`#inclide <stdio.h>` = 疑似命令`#include`+ファイル名`stdio.h`

## 4章：数値の表示と計算

### 数値の種類
|書式|進数|
|:---:|:---:|
|数字|10進数|
|0数字|8進数|
|0x数字|16進数|


関数名・変数名ルール
1. 半角アルファベット、半角数字、半角_
2. 一文字目に数字は使えない
3. 予約語もダメ

### 演算子
- pythonと同じように `+=` とか使える
- 実数と整数の演算の結果は実数に変換される


## 5章：数値の記憶と計算
### 型変換
キャスト変換
: - 強制的に型を変換する機能 `(変換する型名) (数字や変数名)`（例：`(int) (1.05 * 360)`）
  - 変換しないとおかしな数字になる<br>
    （例えば、1.03*9=9.270000について、<br>
    `printf("%f\n",1.03*9);`は正しく表示されるが、<br>`printf("%d\n",1.03*9);`は-10486とかおかしな数字になる）

### 数値の桁揃え
`printf`関数には文字や数値の桁を揃える機能がある

- 整数の末尾で揃えて表示する場合
    - `printf("%桁数d",d);`
    - 例：`printf("%5d",100);  # 100`

- 桁を0で埋める場合
    - `printf("%0桁数d",d);`
    - 例：`printf("%05d",100);  # 00100`

- 実数の桁揃え
    - `printf("%全体桁数.小数点桁数f",f);`
    - 全体桁数：少数の桁数+小数点
    - 例：`printf("%6.2f",3.14159);  # 3.14`

## 6章+21章：キーボードからの入力

### 入力用の関数
- `scanf("入力変換指定子",&変数名);`
- 変数名は先に型宣言しておくこと！
- 入力変換指定子はほとんどは出力変換指定子と同じ
    - 例外：実数
    入力変換指定子 → `%lf`（出力変換指定子 → `%f`）
- 複数の入力
    例：`100 200` → `scanf("%d%d",&data1,&data2);`

### 入力の恐怖
**`scanf` 関数はミスに弱い！！！**
- 区切り文字が入力とプログラムで違う（ ` ` と `,`とか ）場合、意図しない値が入る
- 極端に大きい数字を入力した場合も意図しない値が入る
- 入力文字の型がプログラムの入力変換指定子と違う（ `%d` なのに `ABC` とか入れちゃう）場合、よくわからないことになる

### 現実的なキーボードからの入力の受け取り方法

##### 1. `gets`関数
- キーボードから１行の文字列を入力する関数
- `gets(文字配列変数名);`（先に文字配列の変数宣言しておき、その変数名を`gets`に入れる、文字配列の変数の宣言方法は[後述](##14章：文字列を扱う方法)）
    ```
    char str[32];

    gets(str);  // 入力
    puts(str);  // 出力
    ```
- `#include <stdio.h>` が必要
- １行の文字列の出力には`puts`関数が便利（同じく`#include <stdio.h>` が必要）
- `\n` を格納しない
- **`gets`関数に渡される文字配列の長さは明らかでないため、格納できる要素数以上の入力を受け取ることができ、バッファオーバーランを起こす可能性がある**
##### 2. `fgets`関数
- `fgets(文字配列変数名, 配列の要素数, ファイルポインタ)`（先に文字配列の変数は宣言しておく）

    - ファイルから文字列を読み込むための関数
    - C言語は**全ての周辺機器をファイルとして扱え**、キーボードには`stdin`というファイルポインタが割り当てられている
    - ファイルポインタに`stdin` を指定すれば、キーボード入力ができる

    ```
    char str[32];

    fgets(str, sizeof(str), stdin);
    puts(str);
    ```
    要素数の限界となる部分で入力を打ち切るのでバッファオーバーランは起こらない
- `#include <stdio.h>` が必要
- 文字配列の要素数は`sizeof(文字配列)`が便利
- `\n` を格納する（のでこれを終端文字とすると良い）

##### 3. `atoi`関数
- `fgets`関数を使用した場合、数値の入力ができない
- 文字列を数値に変換するために`atoi`関数を用いる
    ```
    char str[32];
    int val;

    fgets(str, sizeof(str), stdin);
    val = atoi(str);
    printf("%d\n",val)  // puts関数は文字列のみに使える
    ```
- 数値以外が含まれていても`atoi`関数はそれを無視するので、`scanf`関数のようなエラーは発生しない

（後で要補足）

##### 4. `strtok`関数
- 複数の数値を記号で区切って入力したい場合は、`atoi`関数を使用する前に区切り文字で分けてそれぞれを数値に変換する
- `strtok` 関数は
    1. 文字列を最初の区切り記号を見つけるまで検索
    2. 見つけた区切り記号を`EOS`に置き換える
- 使い方は
    - 一番最初の単語を取り出す場合、`単語のアドレス値 = strtok(文字配列, 区切り文字)`
    - 次の単語を取り出す場合、`単語のアドレス値 = strtok(NULL, 区切り文字)`
    - 単語が見つからない場合は`NULL`を返す
    ```
    int i, j val[10];
    char str[32], *ch;

    fgets(str, sizeof(str), stdin);

    ch = strtok(str, "\n");  // 一番最初の単語を取り出す

    for (i = 0; i < 10; i++){
        if (ch == NULL) {
            break;
        } else {
            val[i] = atoi(ch);
        }
        ch = strtok(NULL,"\n")  // 次の単語を取り出す
    }

    for (j=0; j <i; j++) {
        printf("%d\n",val[j])
    }
    ```

#### `strtok`関数の２回目以降の第一引数がNULLの理由
- `strtok`関数はポインタを返り値とする関数
1. 最初の呼び出しで、`strtok`関数は対象の文字配列の最初のポインタを返す
2. 区切り文字に到達するまで前方探索し、
    - 区切り文字が見つかった場合は区切り文字をNULL(EOS)に置換、置き換えたNULLのポインタを返す
    - 区切り文字が見つからないまま文末のEOS(NULL)に到達した場合、NULLを返す
3. ２回目以降の呼び出しでも同様に


？？？？？？わかんなくなってきた


## 7章：比較と判断、8章：場合分け処理
### if 文
```
if (条件1){

    処理1

} else if (条件2){

    処理2

} else {

    処理3

};
```

### switch文
```
switch (条件式) {
    case 数値:
        実行文;
        break;
    case 数値:
        実行文;
        break;
    default:
        実行文;
        break;
}
```
- 条件式には 整数値 or 結果が整数値になる式 を入れる
- `case`に入れられるのは整数値のみ
- `default`: 条件式の数値が全ての`case　数値`と一致しない場合の処理
- 同じ実行文の`case`はまとめて書ける！
    ただし `case 1,2,3:` みたいな書き方はできなくて、
    ```
    case 1:
    case 2:
    case 3:
        実行文;
        break;
    ```
    みたいにそれぞれ書く必要はある
- `break` を入れないと次の`case`の式を実行する（switch文は対応する番号のcase文までジャンプする機能しかないので、`break`でswitch文全体から抜ける必要があるため）


## 9章：回数が決まっている繰り返し

### C言語の繰り返し
- for文
- while文
- do ~ while文

### for文
```
for (初期化; 条件式; 更新) {
    繰り返す操作;
}
```
- 初期化：カウント変数の初期値
- 条件式：ループ終了条件
- 更新：カウント変数の更新

```
for (;;){
    処理;
}
```
で処理の無限ループ

### while文
pythonとそんなに変わらんので省略

### do ~ while 文
```
do {
    繰り返す文;
} while (条件式);
```
- 判定が最後にある（while文は最初にある）→ 少なくとも１回は実行される
- 入力チェックに役立つ！！

#### 入力チェック
例：円の半径を計算するプログラム

- if文
```
int r;
double s;

scanf("%d",&r);

if (r < 0){
    printf("r is not nagatibe value \n");
} else {
    s = r * r * 3.14;
    printf("s = %f \n",s);
}
```

- while文
```
int r;
double s;

scanf("%d",&r);

while (r < 0){
    scanf("%d",&r);
} 

s = r * r * 3.14;
printf("s = %f \n",s);

```

- do ~ while文
```
int r;
double s;

do {
    scanf("%d",&r);
} while (r < 0);

s = r * r * 3.14;
printf("s = %f \n",s);
```

- if文は間違った入力から再入力できない
- whileは再入力できるが、`scanf`関数を2回書いているという無駄がある


## 11章：関数の作り方

**作った関数はそれより後の関数の中でしか使えない！**

回避方法
- main関数よりも上に関数のコードを書く
- プロトタイプ宣言をする


プロトタイプ宣言
: 関数の形（`型 変数名(返り値);`）をプログラムの初めの方で宣言する<br>
あらかじめ宣言しておくことで、他の全ての関数から使えるようになる


- main関数だけはプロトタイプ宣言が必要ない
- `printf`関数などのプロトタイプ宣言は、stdio.h の中に書かれている
    → `#include <stdio.h>` を書く最大の理由

### 関数に数値を渡す
- 引数を使わない場合 → 引数に `void` を使う
- 引数を使う場合 → 引数に `型 変数名` を指定（この時の変数を**仮引数** という）
- 引数を持つ関数のプロトタイプ宣言は、`型 関数名(引数の型);` でOK（仮引数名はいらない）
- 複数の引数を持つ場合は普通に仮引数をカンマで繋いで入れる（プロトタイプ宣言の時も同様）

仮引数
: 関数を宣言する際に引数として与えた変数

実引数
: 宣言した関数を使用する際に渡すもの


### 関数から数値を返す
- return の後に入れる（戻り値）
- 関数宣言の際の型（一番最初）と戻り値の型が違うとエラー
- **戻り値は１つしか返せない！！**　（裏技はある）

## １２章：変数の寿命
### ローカル変数
- **ローカル変数の寿命はブロック内**
    ```
    #include <stdio.h>

    int main(void){
        int v1 = 10;
        int v2 = 20;

        printf("1: v1 %d\n",v1);    //  1: v1 10
        printf("1: v2 %d\n",v2);    //  1: v2 20

        {
            int v1;
            v1 = 30;
            v2 = 40;
            printf("2: v1 %d\n",v1);    //  2: v1 30
            printf("2: v2 %d\n",v2);    //  2: v2 40
        }

        printf("3: v1 %d\n",v1);    // 3: v1 10
        printf("3: v2 %d\n",v2);    //  3: v2 40

    }
    ```

### グローバル変数
- グローバル変数は関数の外(main関数よりも外)で宣言
- グローバル変数には初期値を入れなくともデフォルトの初期値がある
- 同じ名前のグローバル変数とローカル変数がある場合、その関数内ではローカル変数が優先される
- グローバル変数は１つのソースファイル内で共有される


### 静的なローカル変数
普通のローカル変数が関数が呼び出されるたびに初期化されるのに対し、<br>
静的なローカル変数は最初の１回のみ初期化され、関数を呼び出すたびに値が更新される

- 宣言方法 ： `static 型 変数名;`（値を`= 値`で設定もできる）
- 宣言された関数内でのみ変数を使用できる
- プログラムが終了するまで値を保持する
- 初期化しなくとも初期値を持つ

## 13章：複数の変数を一括して扱う

配列
: 同じ型の変数を複数宣言し、インデックスで管理することで複数のデータを一括で取り扱えるようにする

- 宣言方法：`型 配列名[要素数];`
- `配列名[インデックス]` で各要素にアクセス
- 配列の初期化：`型 配列名[要素数] = {0番目の値, 1番目の値, ...};`
- ↑の方法で宣言した場合、要素数は省略できる（`[]`は省略できない）
- for文で扱える


#### 要素数を求める → `sizeof(配列名)`

#### 配列のコピー → `memcpy(コピー先の配列名, コピー元の配列名, 配列全体のサイズ)`
- **memcpy は配列サイズを考慮しないので、コピー元の配列サイズがコピー先の配列サイズよりも大きい場合、強引にコピーする**
- **はみ出した部分は無関係な他の変数や配列を上書きしてしまい、重大な計算エラーを起こす（バッファオーバーラン）**


## 14章：文字列を扱う方法

**C言語には文字列を記憶する変数がない！！！**

文字列は何文字になるか事前に予測できないため、必要なメモリサイズを事前に確保できないため

C言語以外はメモリを
- 固定的に確保（メモリ消費量のムダが多くなるが、高速）
- 可変的に確保（メモリ消費量を減らせるが、低速）

して文字列変数を用意している

### C言語で文字列を扱う方法
C言語で文字列を扱う場合 → 1文字を扱う型 `char` の配列を使用

`char`型
- 文字は''（シングルクォート）で囲う
- 代入されるのは文字コード（普通の整数型と変わらない）
- なので計算もできる（`char c = 'A'+ 9;`など、この結果は`J`）


### 文字コード

文字コード
: コンピュータで使われる文字に１対１で対応する番号を付けて表現する方法

文字コードを調べる関数（`#include <ctype.h>` が必要）
|関数名|調べられる文字の種類|調べられる文字一覧|
|:---:|:---:|:---:|
|isalnum|英数字|A~Z, a~z, 0~9|
|isdigit|10進数|0~9|
|isxdigit|16進数|A~F, a~f, 0~9|
|isalpha|英字|A~Z, a~z|
|isupper|英大文字|A~Z|
|islower|英数字|a~z|
|ispunct|記号|!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~|
|isspase|スペース|0x09~0x0D 0x20|


#### 配列にするときの注意
- 文字列の終わりであることを表すために、**EOS (End of Strings)** を配列の最後に記憶しておく必要がある

文字配列を宣言するとき（"MARIO"という文字列を扱うとする）
- 初期化しない場合、
    - 宣言時の要素数を文字数+1する（例：`char str[6]`と宣言し、インデックス0~4に文字、インデックス6に'\0'を代入）
- 初期化する場合
    - `char str[6] = {'M','A','R','I','O'}` （先に文字配列を宣言してても同じ）
    - `char str[] = {'M','A','R','I','O','\0'}`　（先に文字配列を宣言してても同じ）
    - 文字リテラル（ "" で囲った文字列 ）を使用する（`char str[] = "文字列(charは日本語扱えないけどね)";`）**宣言の際にしか使えない！！**


### 文字列処理関数
#### 文字列を数値へ変換 → `atoi`関数
- `#include <stdlib.h>` が必要
- 符号( \+ や - )が入った文字列も変換できる
- 数字と関係ない文字列が指定された場合は0に変換する
- 実数に変換する場合は `atof`関数を使用


#### 文字列をコピー → `strcpy` 関数
- `#include <string.h>` が必要
- `strcpy(コピー先の文字列配列, コピー元の文字列配列);`
- 先頭から指定文字数だけをコピーする場合、`strncpy` 関数を使用
    - `strncpy(コピー先の文字列配列, コピー元の文字列配列, コピーする文字数);`
    - コピーされた文字列配列の最後にEOSが入っていない場合があるので、strncpy実行後に `コピー先文字列配列名[コピーする文字列] = '\0';` を追加する！！（EOSを忘れると無関係の文字がたくさん出てきてそしてエラーになる）


#### 文字列リテラルを連結
- そのまま並べておけばOK( + とかもいらない、`"DORAGON" "QUEST"`でOK)


#### 文字列配列の連結 → `strcat`関数を使用
- `#include <string.h>` が必要
- `strcat(元の文字列が記憶された配列, 追加する文字列の記憶された配列);`
- 第一引数の元の文字列配列に第二引数の追加する文字列配列が連結される
- ので、元の文字列配列は「元の文字列+追加する文字列」の長さを確保しておく必要がある（長さが足りないとバッファオーバーランエラーの原因となる）

#### 究極の文字列合成関数 → `sprintf` 関数
- printf関数と同じ機能を持つが、結果を配列の中に記憶する
- `#include <stdio.h>` が必要
- `sprintf(結果を記憶する配列, 書式文字列, 各種変数・・・);`

#### 文字列の入力 → `scanf` 関数を使用
- 入力変換指定子（`%s`）は使用
- **出力先の変数名に`&`はつけない！！**
- 配列の要素数よりも多く入力するとエラーの原因となる
    - → 入力指定子で要素数を指定する（要素数が32なら、`%32s` と指定する）
- スペースを文字列の中に入力できない（区切り文字として認識されるため）

#### 文字列のカウント
- 文字列の先頭からEOSが出現するまでの数を数える
    - for文
    - `strlen` 関数（`#include <string.h>` が必要）

#### 文字列の比較
- `==` は全く同じメモリを使う配列かどうかを比較するものなので使えない
- for文で全要素の比較
- `strcmp` 関数（`#include <string.h>` が必要）

## 15章：ポインタ変数の仕組み
### メモリの仕組み
bit（32bit や 64bit）
: CPUが１回で扱うことのできるメモリの２進数での桁数

メモリは8bit（= 1 Byte）単位で扱う（1バイトことにアドレスがある）

### 変数とメモリの関係

#### アドレスの表示
変数のアドレスを表示する
```
int i;
printf("%p\n",&i);
```
- ポインタの出力変換指定子 → `%p`
- アドレスは16進数

#### 配列の番号
配列のアドレスを表示する
```
#include <stdio.h>

int main(void)
{
    int array[10];
    printf("array___(%p)\n", array);
    printf("array[0](%p)\n", &array[0]);
    printf("array[1](%p)\n", &array[1]);
    printf("array[2](%p)\n", &array[2]);
    return 0;
}
```
- 配列そのものを表示する場合は先頭の`&`はいらない
- **配列変数には配列の最初の要素のアドレスを保持する**
- 配列の各要素を（`array[1]`とかで）参照する = 配列のアドレス + 要素番号のメモリを参照する
- **配列はメモリの連続した区間を使う！！**

### &付けが必要な変数の正体
- `&` → アドレスの変数を求める演算子
- C言語において、関数の引数にできるのは数値のみ<br>
        **引数に数値を渡す方式 → 値渡し**
- 変数を実引数に指定しても、渡されるのは変数内の数値<br>
    → 関数によって（実引数に指定した）変数の中身の変更はできない
- &演算子（アドレス演算子）でアドレスを求め、そのアドレスの数値を渡す<br>
    → 関数に実引数の変数のアドレスを渡し、そのアドレスのメモリを書き換える関数ならば、呼び出し側の変数を書き換えられる<br>
    **参照渡し：アドレスを渡す処理を自動的に処理してくれる機能**

**C言語は値渡ししかできない**（ただし、アドレスの数値を渡すことを慣習的に参照渡しと呼ぶことがある）

#### scanf関数で&をつける理由　
（scanf関数：`scanf("入力変換指定子",&事前に宣言した変数名)`）

C言語は値渡ししかできない（関数の引数には数値しか渡せない）<br>
→ 変数は渡せないので、そのままでは入力を記憶できない<br>
→ 変数のアドレスを（数値として）渡せば、そのアドレスに入力を渡せる = そのアドレスの変数に値を保存できる<br>

**文字列の入力の場合、変数名に&は要らない**
- 文字列は配列
- 配列名はそのものが配列の最初の要素のアドレスを保持しているので、&がなくともアドレスを返す

配列のアドレスが指定できればいいので、
```
char str[256];
scanf("%s", &str[0]);
printf("%s\n",str);
```
と
```
char str[256];
scanf("%s", str);
printf("%s\n",str);
```
は同値

### アドレスの値を記憶する変数

ポインタ：アドレスを扱う３つの機能の総称
1. ポイント型
2. ポイント値
3. ポインタ変数


#### ポインタ型
- アドレスを記憶する変数の型
- 通常の型と異なり、他の型から作り出される派生型
- ポインタ型のサイズは派生元の型によらない（全てのポインタ型は同じサイズ）

例:
- int型 + ポインタ型 = intへのポインタ型
- double型 + ポインタ型 = doubleへのポインタ型


###### なぜポインタ型は複合型である必要があるのか？？
**→ 指定アドレスに記憶された数値を正しく取り出すため！**<br>

正しく取り出せない例
- 型によって読み取るメモリのサイズが異なる<br>
（アドレスにある値がint型のとき、メモリ上の4バイトのサイズを読み取るが、double型のときは読み取るサイズは8バイト。<br>メモリは1つのアドレスで1バイト格納するので、int型では4つのアドレス、double型では8つのアドレスを読み取る」）
- 型によってメモリ上の２進数の読み方が違う場合


ポインタ型はその変数の値が保存されたメモリの最初のアドレスを保持するので、変数の値を正しく読み取るためにポインタ型は

ポインタはそのアドレスにある変数の値の型を知っておく必要があるため、

あらかじめ値の型からポイント型を作っておくと、
そのポイント型の変数に記憶された値を取り出せる？？？

###### voidポインタ
- 派生型ではなく単独で存在するポインタ型
- どんな変数のアドレスも記憶できるが、元の変数の型はわからないため値の取り出しはできない
- `printf`関数について、出力演算子`%p`は引数をvoid*型とみなしてそのアドレス値を16進数表記で出力する（ので、C言語ポインタ完全制覇の方では`void*` にキャストするとかいってるがキャストしなくとも出力できるっぽい）
- ```
  int hoge = 5;
  void *p;
  
  p = &hoge;    \\  通る
  printf("%d\n",*p);    \\  エラー
  printf("%d\n",*(int*)p);    \\  通る
  ```

#### ポインタ値
ポインタ型の変数が記憶できる数値（＝変数のアドレスの値）


int型とは何が違うのか？
- 実際は何も変わらん（どっちも整数値）
- しかし目的は全く違う
    - 整数型 → 値そのものを計算を行うための型
    - ポイント型 → 値のアドレスに入った変数の値を計算に使うための型
- ので、同じ型として扱うと混乱を起こすだけでメリットがない

#### ポインタ変数
- ポインタ型で宣言された実際の変数
- その元となった型の変数のアドレスを自由に代入できる
- 記憶してるアドレスのメモリの読み書きができる


ポインタ変数が指し示している変数の計算が必要なときには普通の変数として振る舞う
- ポインタ変数モード：アドレスへの代入と足し引き算のみ（記憶しておく必要があるのはアドレスのみなので）
- 通常変数モード：通常の変数と同様に扱える

ポインタ変数はこの２つのモードを切り替えて使うことができる

↑ ???うまい用語を探してください


### ポインタ変数の宣言
- `int *p;`
- `int* p;`

`*`：間接演算子

訳がわからん。要補足

#### ポインタ変数へのアドレスの代入

代入するアドレスは？（物理 or 仮想）<br>
ポインタ変数に代入されるのは仮想メモリのアドレスである必要がある

仮想メモリ
: 各アプリケーションが使用するメモリの重複を防ぐために、それぞれが使用できるメモリをOSが割り振る仕組み

```
int *p;
int i;
p = &i;
printf("p = %p\n", p);
printf("&i = %p\n", &i);
```
- p: ポインタ変数、i: 普通の変数
- &iでアドレス演算子を求め、それをポインタ変数pに代入している
- どっちもアドレスなので、%p指定子で表示できる


#### ヌルポインタ
- 宣言直後のポインタ変数にはデタラメな値が入っていて、その値が使用可能なアドレスとは限らない
    - そのまま使うと確実にバグる
    - それを防ぐため、アドレスに値を代入したかどうかを区別する必要がある

`int *p = NULL;` と宣言したポインタ変数`p`にはアドレスが代入されない（まだ使える状態になっていない）


`if p == NULL` での比較でそのポインタ変数にアドレスが代入されているかどうかが判断できる

`int *p = 0;` でもヌルポインタは代入できるが、NULLは必ずしも0ではない

（NULLはあくまで正しいアドレスが代入されていない識別子で、計算に使うための0とは明確に区別されるものである）



#### モードの切り替え

ポインタ変数のモード
- ポインタ変数モード
- 通常変数モード

##### ポインタ変数モード
何もしなければポインタ変数モード


##### 通常変数モード
- ポインタ変数の前に`*`をつける


通常変数モードに切り替えたポインタ変数は通常の変数と同じように機能するが、そのとき使われるメモリはポインタ変数モードの時に代入されたアドレスである。

ポインタ変数モードの時に読み書きしたいメモリのアドレスを代入し、
その後、通常変数モードに切り替えてそのメモリを操作する

例：
```
int *p;
int i;

p = &i;
*p = 10; /* 通常変数モードに切り替えたポインタ変数に代入 */

printf("*p = %d\n", *p);
printf("i = %d\n", i);
```

結果：
```
*p = 10
i = 10
```

- このときの変数iと通常変数モードの*pは全く同じメモリ領域を使っている
- ポインタ変数pを通常変数モードに切り替え、pが記憶したアドレスに10を代入 → pが記憶したアドレス = iのアドレスなので、結果として変数iの値は10に書き換えられる


### 引数による情報の受け渡し

#### ポインタ型の引数

C言語の関数の返り値は通常1つだけ

関数が複数の値を返せるようにするには、引数にポインタ型の変数を渡す
- C言語は値渡ししかできないので、関数の引数に変数を指定しても関数に渡されるのはその中身の値である
- ポインタ型変数は既に存在する変数のアドレスを保持するので

?????

```
void func (int *pval) {
    printf("pval = %p\n",pval);
    *pval = 100;
    return;
}
```


```
int val = 10;
print("&val = %p\n",&val);

func(&val);
print("val = %d\n",val);
```



## 16章：複数の型をまとめる

#### 構造体の宣言方法
```
struct student {
    int year;
    int clas;
    int numer;
    char name[64];
    double stature;
    double weight;
};
```
- `struct` で構造体を宣言
- その構造体に名前をつける（構造体タグ、今回だったら`student`）
- 使用する関数よりも先に宣言する必要がある

##### 宣言した構造体を型として扱う
- 上記の方法では、構造体変数を宣言する際に`struct 構造体タグ 構造体変数名` （つまり変数宣言時に`struct` が必要）
- `typedef` を使用して構造体タグを新しい型として定義する<br>

↑これのメリットがわからん<br>
多分ポインタ変数とかにするときに便利になるからかも？？

方法１：
```
struct student_tag {
    int year;
    int clas;
    int numer;
    char name[64];
    double stature;
    double weight;
};

typedef struct student_tag student;
```

方法２：
```
typedef struct student_tag {
    int year;
    int clas;
    int numer;
    char name[64];
    double stature;
    double weight;
} student;
```

方法３：
```
typedef struct {
    int year;
    int clas;
    int numer;
    char name[64];
    double stature;
    double weight;
} student;
```


#### 構造体の使い方
1. 構造体の型をとる変数を宣言する<br>
    `struct 構造体タグ 構造体変数名;`<br>（今回だったら`struct student data;`）<br>
2. `構造体変数名.要素名` で元の構造体タグが持つ各要素にアクセスする<br> （今回だったら`date.year = 10;`とか）

- 構造体変数は構造体タグで宣言された全ての型を持つ
- 構造体変数自体を変数として扱うこともできる<br>
    今回だったら<br>
    ```
    struct student data1, data2;
    /* data1に値を代入 */
    data2 = data1;    \\  data2の値はdata1と等しくなる
    ```
- だからと言って構造体変数同士の比較はできない（`data1 == data2` はだめ）
- 構造体も関数の引数にできる（C言語の関数は値渡しなので構造体の中身は変更されない）
- 構造体型のポインタ変数も作れる<br>
    ```
    student data;
    student *pdata;

    pdata = &data;    // ポインタ変数の初期化

    (*pdata).year = 10;     // 値の代入
    strcpy((*pdata).name, "MARIO");     // 文字列の代入

    \* もしくは *\

    pdata->year = 10;     // 値の代入
    strcpy(pdata->name, "MARIO");     // 文字列の代入
    ```
- 構造体型のポインタ変数も関数の引数にできる<br>
    ポインタ変数を引数にする関数
    ```
    void student_print(student *data) {
        printf("学年：%d\n",data->year);
        return;
    }
    ```
    関数を使う
    ```
    student date;
    data->year = 3;

    student_print(&data);    \\ アドレスで関数を呼び出す
    ```
    - 構造体をポインタ変数として関数に渡すと、関数内で値を変更できるようになる → 関数によって複数の値をの変更ができる（通常は返り値が１つのみなので関数で変更できる値は１つ）
    - 大きい構造体の場合、値渡しでは時間がかかるが、参照渡しならばだいぶ早くなる
- 構造体型の要素として持つ配列を作ることもできる<br>
    ```
    student data[10];    \\ 構造体型の要素を持つ配列dataを宣言

    data[1].year = 10;    \\ 配列dataの要素（今回だったらindex=1）の構造体のyear要素にアクセスし値を代入
    ```


## 17章：ファイルの取り扱い

### ファイルの開閉
#### ファイルを開く → `fopen` 関数

`FILE型 *変数名 = fopen(ファイル名, モード);`<br>
例：`FILE *file = fopen("test.txt", "w");`

- `fopen`関数とその引数から得られる返り値を初期値としたFILE型のポインタ変数を宣言する
- `#include <stdio.h>` が必要
- モード：ファイルを開く目的を表す文字列<br>
    |モード文字列|目的|
    |:---:|:---:|
    |r|読み込み<br>ファイルがないときは失敗|
    |r+|読み書き<br>ファイルがないときは失敗|
    |w|書き込み<br>ファイルがあっても空のファイルを作る|
    |w+|読み書き<br>ファイルがあっても空のファイルを作る|
    |a|追加書き込み<br>ファイルがないときは作る|
    |a+|読み書き<br>ファイルがないときは作る|
- FILE型は構造体、`fopen`関数を実行するとファイル情報をもつFILE型へのポインタが返される
- このポインタ（そしてポインタが格納されたポインタ変数）は識別子としてのみ扱われる（ポインタ演算や構造体の要素を使ったりはしない）

#### ファイルを閉じる → `fclose` 関数
`fclose(FILE型のポインタ変数);`<br>
例：`fclose(file);`
- マルチタスクができるOSにおいて、あるファイルが異なるアプリケーションによって同時編集されないように（されるとコンフリクトするので）`fopen` 関数で開いたファイルは他のアプリケーションで開けないようにロックされる
- ロックを外すためにはそのアプリケーションでのファイル編集が終了したことを提示する（アンロックする）必要があり、`fclose`関数はアンロックするために必要である
- また、`fopen`関数でファイルをメモリにのせ、`fclose`関数の実行で初めてディスクに書き込む（つまりIOの頻度を減らす）ことで高速化ができる

#### ファイルへの書き込み　→ `fprintf` 関数

`fprintf(ファイルポインタ, 書き込み文字列, 変数, ....);`<br>
例：
```
int i = 100;
FILE *file = fopen("test.txt","w");
fprintf(file, "%d",i);
fclose(file);
```
- ファイルを読み込みモード（r）で開いた場合、`fprintf`関数を実行しても何も起こらない
- 追加モード（a,a+）で開いた場合、`fprintf` 関数を実行すると開いたファイルの最後にデータが追加される

#### ファイルからの読み込み → `fscanf`関数
`fscanf(ファイルポインタ, 読み込み文字列, &読み取った内容を格納する変数);`<br>
例：
```
int i;
FILE *file = fopen("test.txt","r");
fscanf(file,"%d",&i);
fclose(file);
```
- 入力変換指定子に一致しない文字は無視される（今回の場合、ファイルの内容が`test100`であったとき、`i`に格納されるのは`100`である）
- 入力変換指定子に`%s`を指定すれば読み取った文字列はそのまま格納できるが、スペースなどの空白文字が含まれる場合、その部分までしか変数に格納されない
- カンマ`,`ならOK<br>
    例：
    ```
    int i,j;
    FILE *file = fopen("test.txt","r");
    fscanf(file, "%d,%d",$i,&j);
    fclose(file);
    ```
    とかは`i`, `j`に値がちゃんと入る<br>
    （ test.txt の内容が`23,56`の時、`i`には23、`j`には56が入る）

#### バイナリファイルの読み書き
ファイルの種類
- バイナリファイル：バイナリで記録されたファイル
    - サイズが小さく高速
    - 扱いがアーキテクチャやOS、アプリケーションに依存
- テキストファイル：文字コードで記録されたファイル
    - 文字コードさえ指定すれば全ての場合で同様に扱える
    - 人間が認識できる文字に変換できるので、編集が楽

##### ファイルの開閉
- ファイルを閉じる → `fclose` 関数を使用
- ファイルを開く → `fopen`関数を使用、ただしモード文字列の最後に"b"をつける（`+`があるモードの場合は`+`の前、つまり`ab+`とか）


##### ファイルへの書き込み → `fwrite`関数
`fwrite(書き込む変数のアドレス, 1項目のサイズ, 項目数, ファイルポインタ);`<br>
例：
```
inf buf = 100;
FILE *file = fopen("test.dat","wb");
fwrite(&buf,sizeof(buf),1,file);
fclose(file);
```
配列を書き込む場合：
```
int buf[] = {10,100,1000,10000};
FILE *file = fopen("test.dat","wb");

fwrite(buf,sizeof(buf),file);
fclose(file);
```
- 配列名はその配列の先頭のアドレスを保持するので（変数に格納されているのがそもそもアドレスなので）`&`をつける必要がない


##### ファイルの読み取り → `fread`関数
`fread(読み込む変数のポインタ, １項目のサイズ, 項目数, ファイルポインタ);`<br>
例：
```
int buf;
FILE *file;

file = fopen("test.dat","rb");
fread(&buf,sizeof(buf),1,file);
fclose(file);
```

### コマンドライン引数からのファイル名取得

`int main(int argc, char *arg[]);`
- `main` 関数の型を`int`にする
- 引数をつける
    - `argc`：コマンドラインの数
    - `argv`：文字配列へのポインタ変数

例：
```
int main(int argc, char *argv[]) {
    if (argc > 1) {
        処理
    }

    fflush(stdin);
    getchat();

    return 0;
}
```

- `fflush(stdin);`と`getchat();`は画面の表示を止めるための処理（実行待ちの状態で適当なキーを押せば表示が終了する）
- `fflush(stdin);`
    - `fflush()`：出力バッファを強制出力する関数
    - `stdin`：入力バッファ<br>
    なので、とても邪道？？？？？？

#### オプションの解析

ようわからん！！！！放置！！！！！

## 18章：マクロ機能

### 定数の宣言方法
- `#define`
- `const`
- `enum`

慣習として定数名は全て大文字のアルファベット

#### `#define`
- `#define 定数名 値`
- 最後に`;`は要らない!!
- 値は数値でも文字リテラルでもOK
- 定数を宣言する際、変数名に値の型をつける必要はない<br>
    （例：`#define AUTHOR "MMGames"`）


#### `const` 定数
- **値を変更できない変数**
- `const 型 定数名;`（例：`const double EXCISETAX = 0.05;`）
- `const`定数は配列の要素にできない(C++やC99ではいけるらしい)

`#define` はプリプロフェッサディレクティブなので、コンパイル前に展開される

`const`はあくまで変数なので、コンパイル時に処理される

- [constとdefineの違い](https://ja.stackoverflow.com/questions/13061/constとdefineは何が違うのですか)

##### `enum`定数
```
enum タグ名（省略可） {
    定数名,
    定数名,
    定数名,
};
```
- 名前に対して上から順に自動で数値が割り振られる（0-index）
- ので大量に定数を定義したいとき便利
- フラグ定数として使うのが便利

    例：
    ゲームでキャラクターの状態を {0:正常, 1:毒, 2:麻痺, 3:呪} と表すとする<br>
    `#define`を使用する場合の定数定義
    ```
    #define NOMAL 0
    #define POISON 1
    #define NUMBLY 2
    #define CURSE 3
    ```
    `enum`を使用する場合の定数定義
    ```
    enum {
        NOMAL,
        POISON,
        NUMBLY,
        CURSE, 
        /* 最後の`,`は文法上は正しくないので
        組み込み向けコンパイラとかでは通らないこともあるが,
        大抵の場合は動くのでつけた方が定数名の追加・修正の際に便利 */
    };
    ```
- 定数として使用できるのは整数値のみ
- `enum`は定数名に自動的に整数を割り振ってくれるが、こちらから指定もできる

    例：
    ```
    enum {
        ENUM_0,         // 0
        ENUM_1,         // 1
        ENUM_2 = 5,     // 5
        ENUM_3,         // 6
        ENUM_4,         // 7
        ENUM_5 = 9,     // 9
    };
    ```


### 簡易的な関数の実現

**`#define`は２つめのオペランドを１つめのオペランドに置き換えるオペレータである**

→ 定数だけでなく、簡単な関数（マクロ）も定義できる


例：
`#define PRINTM(X) printf("%d\n",X)`

#### マクロの副作用

例：

```
#define GET_TRAPEZOID_AREA(A,B,H) (A+B)*H/2

....

int up,down, h,s;

scanf("%d,%d,%d",&up,&down,&h);
s = GET_TRAPEZOID_AREA(up, down,. h+3);
printf("%d\n",s);
```

`5,10,5`を入力したとき、
- 欲しいのは`60`（ = (5+10)*(8/2)）
- 出てくるのは`76`

`#define` は置き換え命令なので、<br>
`GET_TRAPEZOID_AREA(up, down,h+3)`を`(A+B)*H/2` で置き換えると、`(up+down)*h + 3/2` になる（ので、76.5でintなので76）

解決法１：<br>
呼び出しの際にかっこをつける<br>
`GET_TRAPEZOID_AREA(up, down, (h+3))`

解決法２：<br>
マクロの方にかっこをつける<br>
`#define GET_TRAPEZOID_AREA(A,B,H) (((A)+(B))*(H)/2)`

## 19章：動的配列

**`malloc`（エムアロック）関数**<br>
`ポインタ変数 = malloc(必要なメモリのバイトサイズ);`
- `#iclude <stdlib.h>` が必要
- 返されたポインタ変数には確保された配列の先頭アドレスが代入され、これに`[]`を使用すれば通常の配列と同様に使用できる
- `maclloc`関数で指定できるのはバイト単位のサイズなので、任意の要素数の配列を確保するには`sizeof`演算子を使用する
- メモリ確保に失敗した場合、`NULL`を返し、そのまま使用すると強制終了する（ただし対策法は特にない）
- プログラム終了までそのメモリを確保する
- `malloc`関数が返すアドレスはvoid型のポインタ


`maclloc`関数で確保された配列を動的配列と呼ぶ

**`free`関数**<br>
`free(ポインタ変数);`
- `malloc`関数で確保されたメモリが不要になった場合にそのメモリを解放する関数
- これを忘れるとメモリを無駄にするので、`malloc`関数を使ったら必ず行うこと
- （プログラム終了後にはOSがメモリ解放してくれるけども、要所要所で`free`関数は使った方がいい）

例：
```
int i;
int* heap;
heap = (int*)malloc(sizeof(int)*10);

if (heap == NULL) exit(0);

for (i = 0; i < 10 ; i++) {
    heap[i] = i;
}

/* 処理〜〜 */

free(heap);

```
- `sizeof(int)` でint型変数1つのバイト単位を求め、それを10倍にしてint型変数10個分のメモリを確保している

### 動的配列の要素数の拡大

**`realloc`（リアロック）関数**<br>
`新しいポインタ変数 = realloc(malloc関数で使用したポインタ変数, 必要なメモリのバイトサイズ);`

- `malloc`関数で確保したメモリのアドレスが格納されたポインタ変数に対して、中身を保持したまま新しいサイズのメモリを確保する
- `malloc`関数のポインタ変数がNULLの時、`maclloc(sizeof(第二引数))`と同じ働きをする
- メモリ確保が失敗した場合はNULLが返される



仕様としては、
- 第一引数に与えられたメモリオブジェクトを解放し、新たなオブジェクトへのポインタを戻り値として返す
- その際、元のオブジェクトのデータは新たなオブジェクトへとコピーされ、元のオブジェクトは自動的に解放される
- 第一引数に指定したポインタ変数のアドレスと戻り値のアドレスが同じになる場合もある
- 第一引数のポインタ変数のアドレスと`realloc`関数の戻り値のアドレスが異なるとき、元のアドレスを第二引数で指定したバイトサイズ分を拡張するにはメモリの空きブロックが足りないため、`realloc`関数はより広いメモリ領域にメモリブロックを移動する

例：
```
int *heap;
heap = (int*)malloc(sizeof(int)*10);
heap = (int*)realloc(heap,sizeof(int)*100);

/* 処理〜〜〜 */

free(heap);

```
- `realloc`関数を何回も呼び出すとメモリが散らかっていく（フラグメーションが起きる）
- フラグメーションが起こると不安定になる
- ので、最初の`malloc`関数の時点である程度大きいメモリを確保しておくと安心
- `realloc`関数を使う場合も、１回で大きめに確保すると良い

### メモリリーク

メモリリーク
: プログラム中で確保された（不必要な）メモリ領域の解放を忘れ、プログラム終了時まで解放されないまま保持すること<br>
メモリリークすると<br>
    - 他のプログラムやOSの実行に必要なメモリ領域が確保できず、停止・異常終了する
    - 仮想メモリを使用している場合はスワップ動作が増え、処理に時間がかかったり動作が終了する

大規模なプログラムでは、確保したメモリ領域が必要か不必要を判断するのは難しいため、なかなか難しい問題である


**`realloc`関数の戻り値を元オブジェクトのポインタ変数に対して即時に代入してはいけない**

ダメな例：
```
void *ptr = malloc(1);
ptr = realloc(ptr, 2);

free(ptr);
```
- （`realloc`で再確保が失敗したと仮定）
- `ptr`はNULLなので`malloc`関数で確保したアドレスにはアクセスできない
- そのため、元オブジェクトは解放されないままとなり、メモリリークの原因となる
- `free(NULL);`はエラーにならないので、メモリリークの発見が遅れやすい
- つまり上の例の書き方はだめ


良い例：
```
void *ptr = malloc(1);
void *tmp = realloc(ptr,2);

if (tmp == NULL) {
    free(ptr);
    return NULL;
} else {
    ptr = tmp;
}
```
- 一時変数を利用して（一時変数の）ポインタ変数が`NULL`か否かのチェックが必要
- `NULL`の場合は元オブジェクトを解放する

## 20章：複数のソースファイル

大体[Clang_file.md](./Clang_file.md)に書いてあるので省略


