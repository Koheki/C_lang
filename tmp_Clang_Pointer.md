# C言語ポインタ完全制覇

## 1章：

## 2章：Cはメモリをどう使うか

- C言語（にかかわらず現在の環境のアプリケーションプログラムなら）に見えているのは仮想アドレス空間である（`&`演算子で取得されるアドレスは物理メモリのアドレスではなく仮想メモリのアドレスである）
- 関数を呼び出さない（関数名に関数呼び出し演算子の`()`をつけない）で`&`演算を行った際に得られるのは関数の先頭アドレスである




### 関数と文字リテラル

関数本体や文字リテラルはメモリ上の１つの書き込み禁止領域に配置される
ので、隣接したアドレスに配置される

#### 関数へのポインタ

- 詳しくは後述らしい（３章、５章とかで）
- だが現段階でさっぱりわからんのでのちの私頑張ってくれたまへ

### 静的変数

静的変数
: - プログラムの起動から終了まで存在する（静的記憶域領域を持つ）変数
  - 仮想アドレス空間上に固定の領域を占有する
  - 静的変数にはグローバル変数、ファイル内static変数、static指定をつけたローカル変数
  - ↑はスコープが違うためコンパイル/リンク時には異なるものだが、実行時には大体一緒なものとして扱われる

#### 分割コンパイルとリンク

- static指定のない関数とグローバル変数は、**名前が同じであれば**、ソースファイルを跨いで同じものとして扱われる（TODO:グローバル変数についてなんか全然違う事言ってるので、調べて[ファイル](./Scorp_and_Lifetime_inClang.md)とすり合わせること）
- 同じものとして扱うための名前の結合の処理はリンカが行う
- 各オブジェクトファイルは**シンボルテーブル**を持つ<br>
    UNIX系の場合
    - 静的変数はシンボルの結合は必要ないが、リンカにアドレスを割り振ってもらう必要があるのでシンボルテーブルに記載される
    - グローバル変数、関数名は名寄せが必要なのでシンボルテーブルに記載される
    - 各変数名・関数名（各シンボル）には、そのシンボルの種類によってフラグが割り振られる
    - 自動変数のアドレスは実行時に決まるので、リンカの管轄外である

### 自動変数（スタック）
- 自動変数は記憶域領域が定義されたブロック内のみなので、全く同じメモリアドレスの使い回しができる
- しかし自動変数のアドレスは関数の呼び出しかたにより変動し、一定とは限らない

C言語の（見かけ上の）関数呼び出しの手順（今時の処理系はもっと洗練されているが、考え方は変わってないので）
1. 呼び出し側が、実引数の後ろから順にスタックに積む
2. 関数コールに関連する復帰情報（リターンアドレス）などをスタックに積む
3. 呼び出し対象の関数のアドレスにジャンプする
4. その関数で使用する自動変数の分だけスタックを伸長させる（１〜４までに伸長した分のスタックが、その関数が参照する領域）
5. （関数の実行中に複雑な式の評価のために計算途中の値をスタックに置くこともある）
6. 関数の実行が終了すると、ローカル変数分の領域を解放し、リターンアドレスを使用して元のアドレスに戻る
7. 呼び出し側で引数をスタックから除去する


リターンアドレス
: 関数が処理を終えた後に戻るべき場所のアドレス

#### 自動変数をどのように参照するか？

- staticでないローカル変数（自動変数）の変数名はコンパイル後のオブジェクトファイルに残らない
- 自動変数のアドレスは実行時に決まるのでリンカの管轄外

コンパイル済みの機械語コードはどのように自動変数を参照するか？？


ベースポインタ（x86系ではフレームポインタ）

スタックポインタ